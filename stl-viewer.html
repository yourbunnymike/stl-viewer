<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STL Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
            z-index: 100;
        }

        #controls label {
            display: block;
            margin: 8px 0;
            font-size: 14px;
        }

        #controls input[type="file"] {
            margin-bottom: 10px;
        }

        #controls input[type="checkbox"] {
            margin-right: 5px;
        }

        #controls input[type="range"] {
            width: 150px;
            margin: 5px 0;
        }

        .control-group {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <div class="control-group">
            <input type="file" id="file-input" accept=".stl">
        </div>
        
        <div class="control-group">
            <input type="checkbox" id="anaglyph">
            <label for="anaglyph">Anaglyph (Red-Cyan)</label>
        </div>
        
        <div class="control-group">
            <label for="anaglyph-offset">Anaglyph Offset:</label>
            <input type="range" id="anaglyph-offset" min="0" max="0.2" step="0.001" value="0.05">
            <span id="offset-value">0.05</span>
        </div>
        
        <div class="control-group">
            <input type="checkbox" id="autorotate">
            <label for="autorotate">Auto Rotate</label>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Basic Scene Setup
        let scene, camera, renderer, container, controls;
        let mesh;
        let anaglyphMeshRed, anaglyphMeshCyan;
        let autorotate = false;
        let anaglyphOffset = 0.05;

        function init() {
            container = document.getElementById('container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            const light = new THREE.HemisphereLight(0xffffff, 0x080820, 1);
            scene.add(light);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (autorotate && mesh) {
                const box = new THREE.Box3().setFromObject(mesh);
                const center = box.getCenter(new THREE.Vector3());
                
                // Сохраняем позицию относительно центра
                mesh.position.sub(center);
                mesh.rotation.y += 0.01;
                mesh.position.add(center);

                if(anaglyphMeshRed && anaglyphMeshCyan){
                    anaglyphMeshRed.position.sub(center);
                    anaglyphMeshRed.rotation.y += 0.01;
                    anaglyphMeshRed.position.add(center);
                    anaglyphMeshCyan.position.sub(center);
                    anaglyphMeshCyan.rotation.y += 0.01;
                    anaglyphMeshCyan.position.add(center);
                }
            }
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        init();

        // Обновление отображения значения смещения
        document.getElementById('anaglyph-offset').addEventListener('input', (event) => {
            anaglyphOffset = parseFloat(event.target.value);
            document.getElementById('offset-value').textContent = anaglyphOffset.toFixed(3);
            
            if (anaglyphMeshRed && anaglyphMeshCyan) {
                // Сохраняем оригинальную позицию
                const originalPosition = mesh ? mesh.position.clone() : new THREE.Vector3();
                
                // Применяем новое смещение
                anaglyphMeshRed.position.copy(originalPosition);
                anaglyphMeshCyan.position.copy(originalPosition);
                anaglyphMeshRed.position.x -= anaglyphOffset;
                anaglyphMeshCyan.position.x += anaglyphOffset;
            }
        });

        document.getElementById('autorotate').addEventListener('change', (event) => {
            autorotate = event.target.checked;
        });

        document.getElementById('anaglyph').addEventListener('change', (event) => {
            if (event.target.checked) {
                if (mesh) {
                    mesh.visible = false;
                    
                    // Создаем анаглиф-мешes если они не существуют
                    if (!anaglyphMeshRed) {
                        const wireframeMaterialRed = new THREE.MeshBasicMaterial({
                            color: 0xff0000,
                            wireframe: true
                        });
                        anaglyphMeshRed = new THREE.Mesh(mesh.geometry, wireframeMaterialRed);
                        anaglyphMeshRed.position.copy(mesh.position);
                        anaglyphMeshRed.rotation.copy(mesh.rotation);
                        anaglyphMeshRed.scale.copy(mesh.scale);
                    }
                    
                    if (!anaglyphMeshCyan) {
                        const wireframeMaterialCyan = new THREE.MeshBasicMaterial({
                            color: 0x00ffff,
                            wireframe: true
                        });
                        anaglyphMeshCyan = new THREE.Mesh(mesh.geometry, wireframeMaterialCyan);
                        anaglyphMeshCyan.position.copy(mesh.position);
                        anaglyphMeshCyan.rotation.copy(mesh.rotation);
                        anaglyphMeshCyan.scale.copy(mesh.scale);
                    }
                    
                    // Применяем смещение
                    anaglyphMeshRed.position.copy(mesh.position);
                    anaglyphMeshCyan.position.copy(mesh.position);
                    anaglyphMeshRed.position.x -= anaglyphOffset;
                    anaglyphMeshCyan.position.x += anaglyphOffset;
                    
                    scene.add(anaglyphMeshRed);
                    scene.add(anaglyphMeshCyan);
                }
            } else {
                if (mesh) {
                    mesh.visible = true;
                }
                if (anaglyphMeshRed) {
                    scene.remove(anaglyphMeshRed);
                }
                if (anaglyphMeshCyan) {
                    scene.remove(anaglyphMeshCyan);
                }
            }
        });

        document.getElementById('file-input').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const contents = e.target.result;
                    const loader = new THREE.STLLoader();
                    const geometry = loader.parse(contents);
                    
                    // Очищаем старые мешы
                    if (mesh) {
                        scene.remove(mesh);
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) mesh.material.dispose();
                    }
                    if (anaglyphMeshRed) {
                        scene.remove(anaglyphMeshRed);
                        if (anaglyphMeshRed.geometry) anaglyphMeshRed.geometry.dispose();
                        if (anaglyphMeshRed.material) anaglyphMeshRed.material.dispose();
                        anaglyphMeshRed = undefined;
                    }
                    if (anaglyphMeshCyan) {
                        scene.remove(anaglyphMeshCyan);
                        if (anaglyphMeshCyan.geometry) anaglyphMeshCyan.geometry.dispose();
                        if (anaglyphMeshCyan.material) anaglyphMeshCyan.material.dispose();
                        anaglyphMeshCyan = undefined;
                    }

                    const material = new THREE.MeshStandardMaterial({ 
                        color: 0xffffff,
                        metalness: 0.2,
                        roughness: 0.5
                    });
                    mesh = new THREE.Mesh(geometry, material);
                    scene.add(mesh);

                    // Центрируем модель
                    const box = new THREE.Box3().setFromObject(mesh);
                    const center = box.getCenter(new THREE.Vector3());
                    mesh.position.sub(center);
                    controls.reset();

                    // Если анаглиф включен, обновляем анаглиф-мешы
                    if(document.getElementById('anaglyph').checked) {
                        document.getElementById('anaglyph').dispatchEvent(new Event('change'));
                    }
                } catch (error) {
                    console.error('Error loading STL file:', error);
                    alert('Error loading STL file. Please check the console for details.');
                }
            };
            reader.onerror = function() {
                console.error('Error reading file');
                alert('Error reading file');
            };
            reader.readAsArrayBuffer(file);
        });
    </script>
</body>
</html>